rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users: clients can create and update their own user doc, but cannot set protected fields.
    match /users/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;

      // Create: must be the same authenticated user and must not include protected fields.
      allow create: if request.auth != null
                    && request.auth.uid == userId
                    && isCreatingAllowedFields(request.resource.data);

      // Update: only the same user may update non-protected fields.
      allow update: if request.auth != null
                    && request.auth.uid == userId
                    && isUpdatingAllowedFields(resource.data, request.resource.data);
    }

    // Orders: buyer can create an order. Reads and updates limited to buyer, assigned dasher, or admin.
    match /orders/{orderId} {
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid
                    && isValidOrderCreate(request.resource.data);

      allow read: if request.auth != null && (
                    request.auth.uid == resource.data.userId ||
                    request.auth.uid == resource.data.dasherId ||
                    request.auth.token.admin == true
                  );

      // Basic updates allowed by buyer or dasher
      allow update: if request.auth != null && (
                      request.auth.uid == resource.data.userId ||
                      request.auth.uid == resource.data.dasherId ||
                      request.auth.token.admin == true
                    );
    }

    // Runs: readable by involved dasher and staff; writes limited to server/dasher when assigned.
    match /runs/{runId} {
      allow read: if request.auth != null && (
                    request.auth.uid == resource.data.dasherId ||
                    request.auth.token.admin == true
                  );
      allow create: if false; // server (admin) should create runs
      allow update: if request.auth != null && (
                      request.auth.uid == resource.data.dasherId ||
                      request.auth.token.admin == true
                    );
    }

    match /payments/{paymentId} {
      allow read: if request.auth != null && request.auth.uid == resource.data.dasherId;
    }

    match /pair_groups/{groupId} {
      allow read: if request.auth != null;
    }

    // Public collections
    match /schools/{schoolId} {
      allow read: if true;
      allow list: if true;
      // No client writes to schools in this baseline. Manage via admin tooling/functions.
      allow write: if false;
    }

    match /diningHalls/{dhId} {
      allow read: if true;
      allow list: if true;
      allow write: if false;
    }

    match /menus/{menuId} {
      allow read: if true;
      allow list: if true;
      allow write: if false;
    }

    match /hallPools/{poolId} {
      allow read: if true;
      allow write: if false; // Only functions can write pool snapshots
    }

    match /dasherAvailability/{dasherId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == dasherId;
    }

    match /deliveryRequests/{requestId} {
      allow read: if request.auth != null && (
        request.auth.uid == resource.data.buyerId ||
        request.auth.uid in resource.data.candidateDasherIds ||
        request.auth.uid == resource.data.assignedDasherId ||
        request.auth.token.admin == true
      );
      allow create: if false; // Only functions create delivery requests
      allow update: if request.auth != null && (
        request.auth.uid in resource.data.candidateDasherIds ||
        request.auth.uid == resource.data.assignedDasherId ||
        request.auth.token.admin == true
      );
    }

    match /pair_groups/{groupId} {
      allow read: if request.auth != null;
      allow write: if false; // Only functions manage pair groups
    }

    match /paymentMethods/{pmId} {
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid && isValidPaymentCreate(request.resource.data);
      allow update, delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    match /payments/{paymentId} {
      allow read: if request.auth != null && (
        request.auth.uid == resource.data.dasherId ||
        request.auth.uid in resource.data.buyerIds ||
        request.auth.token.admin == true
      );
      allow write: if false; // Only functions create payments
    }

    // Generic fallback deny
    match /{document=**} {
      allow read, write: if false;
    }
  }

  // Helper functions
  function isCreatingAllowedFields(data) {
    // Protected fields that must not be client-set:
    return !(data.keys().hasAny(['canDash','rolePreferences','rating','completedRuns','stripeConnected','schoolId','eligibleSchoolIds']));
  }

  function isUpdatingAllowedFields(old, new) {
    // Disallow changes to protected fields in updates
    let protectedKeys = ['canDash','rolePreferences','rating','completedRuns','stripeConnected','schoolId','eligibleSchoolIds'];
    return !(new.keys().hasAny(protectedKeys));
  }

  function isValidOrderCreate(data) {
    // Basic sanity checks for client-provided order data
    return data.userId is string
           && data.lineItems is list
           && data.priceCents is number
           && data.createdAt is timestamp
           && data.status is string;
  }

  function isValidPaymentCreate(data) {
    return data.userId is string && data.type is string;
  }
}
